{"version":3,"file":"fido.js","names":["async","createRegistration","navigator","credentials","create","Error","axios","get","then","response","createArgs","data","success","msg","recursiveBase64StrToArrayBuffer","cred","authenticatorAttestationResponse","transports","getTransports","clientDataJSON","arrayBufferToBase64","attestationObject","post","authenticatorAttestationServerResponse","catch","error","err","console","checkRegistration","getArgs","id","rawId","authenticatorData","signature","userHandle","obj","prefix","suffix","key","str","substring","length","binary_string","window","atob","len","bytes","Uint8Array","i","charCodeAt","buffer","binary","byteLength","String","fromCharCode","btoa"],"sources":["fido/fido.js"],"mappings":"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","sourcesContent":["/*!\n * Triangle FIDO2 Plugin\n * https://github.com/localzet-dev/FIDO2\n *\n * Copyright Ivan Zorin <creator@localzet.com>\n * Released under the AGPL-3.0 license\n * https://www.gnu.org/licenses/agpl\n *\n * Date: 2023-03-21T22:48Z\n */\nasync function createRegistration() {\n    try {\n        if (!navigator.credentials || !navigator.credentials.create) {\n            throw new Error('Браузер не поддерживается');\n        }\n\n        axios.get('/app/FIDO/create').then(async function (response) {\n            const createArgs = response.data;\n\n            if (createArgs.success === false) {\n                throw new Error(createArgs.msg || 'Произошла неизвестная ошибка');\n            }\n\n            recursiveBase64StrToArrayBuffer(createArgs);\n\n            const cred = await navigator.credentials.create(createArgs);\n\n            const authenticatorAttestationResponse = {\n                transports: cred.response.getTransports ? cred.response.getTransports() : null,\n                clientDataJSON: cred.response.clientDataJSON ? arrayBufferToBase64(cred.response.clientDataJSON) : null,\n                attestationObject: cred.response.attestationObject ? arrayBufferToBase64(cred.response.attestationObject) : null\n            };\n\n            axios.post('/app/FIDO/create', authenticatorAttestationResponse).then(function (response) {\n                const authenticatorAttestationServerResponse = response.data;\n\n\n                if (authenticatorAttestationServerResponse.success) {\n                    return true;\n                } else {\n                    throw new Error(authenticatorAttestationServerResponse.msg);\n                }\n            }).catch(function (error) {\n                throw new Error(error || 'Произошла неизвестная ошибка');\n            });\n        }).catch(function (error) {\n            throw new Error(error || 'Произошла неизвестная ошибка');\n        });\n\n\n    } catch (err) {\n        console.error(err);\n        return false;\n    }\n}\n\nasync function checkRegistration() {\n    try {\n\n        if (!navigator.credentials || !navigator.credentials.create) {\n            throw new Error('Браузер не поддерживается');\n        }\n\n        axios.get('/app/FIDO/verify').then(async function (response) {\n            const getArgs = response.data;\n\n            if (getArgs.success === false) {\n                throw new Error(getArgs.msg);\n            }\n\n            recursiveBase64StrToArrayBuffer(getArgs);\n\n            const cred = await navigator.credentials.get(getArgs);\n\n            const authenticatorAttestationResponse = {\n                id: cred.rawId ? arrayBufferToBase64(cred.rawId) : null,\n                clientDataJSON: cred.response.clientDataJSON ? arrayBufferToBase64(cred.response.clientDataJSON) : null,\n                authenticatorData: cred.response.authenticatorData ? arrayBufferToBase64(cred.response.authenticatorData) : null,\n                signature: cred.response.signature ? arrayBufferToBase64(cred.response.signature) : null,\n                userHandle: cred.response.userHandle ? arrayBufferToBase64(cred.response.userHandle) : null\n            };\n\n            axios.post('/app/FIDO/verify', authenticatorAttestationResponse).then(function (response) {\n                const authenticatorAttestationServerResponse = response.data;\n\n                if (authenticatorAttestationServerResponse.success) {\n                    return true;\n                } else {\n                    throw new Error(authenticatorAttestationServerResponse.msg);\n                }\n            }).catch(function (error) {\n                throw new Error(error || 'Произошла неизвестная ошибка');\n            });\n\n\n        }).catch(function (error) {\n            throw new Error(error || 'Произошла неизвестная ошибка');\n        });\n\n\n    } catch (err) {\n        console.error(err);\n        return false;\n    }\n}\n\n/**\n * convert RFC 1342-like base64 strings to array buffer\n * @param {mixed} obj\n * @returns {undefined}\n */\nfunction recursiveBase64StrToArrayBuffer(obj) {\n    let prefix = '=?BINARY?B?';\n    let suffix = '?=';\n    if (typeof obj === 'object') {\n        for (let key in obj) {\n            if (typeof obj[key] === 'string') {\n                let str = obj[key];\n                if (str.substring(0, prefix.length) === prefix && str.substring(str.length - suffix.length) === suffix) {\n                    str = str.substring(prefix.length, str.length - suffix.length);\n\n                    let binary_string = window.atob(str);\n                    let len = binary_string.length;\n                    let bytes = new Uint8Array(len);\n                    for (let i = 0; i < len; i++) {\n                        bytes[i] = binary_string.charCodeAt(i);\n                    }\n                    obj[key] = bytes.buffer;\n                }\n            } else {\n                recursiveBase64StrToArrayBuffer(obj[key]);\n            }\n        }\n    }\n}\n\n/**\n * Convert a ArrayBuffer to Base64\n * @param {ArrayBuffer} buffer\n * @returns {String}\n */\nfunction arrayBufferToBase64(buffer) {\n    let binary = '';\n    let bytes = new Uint8Array(buffer);\n    let len = bytes.byteLength;\n    for (let i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n}"]}